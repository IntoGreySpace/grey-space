+++
Categories = ["Physical Reality", "Brains"]
+++

The distinction between **process** (dynamic) vs **state** (static) is critical across so many domains and issues. First, we have to recognize that the two are fully interdependent, as processes operate on states, and states are generally inert without associated processes that give them some kind of impact on the world.

For example, all the patterns of ink in a book represent a hugely complex state. But this state doesn't "do" anything until someone processes (i.e., reads and understands) it.

Our brains are wired to try to extract stable ("invariant") states from the world, for example in [object recognition](https://compcogneuro/object-recognition), where we create "permanent" internal representations of objects in the world, even as those objects might be undergoing lots of movement and occlusion.

Therefore, we have a general bias to over-emphasize states, and under-emphasize processes, which by virtue of their dynamic, transient nature are harder to see and understand.

One pertinent example is in contemplating the [[Meaning of life]]: people tend to think in terms of states (e.g., "having a great family and financial success"), whereas the argument on that page is much more focused on a process: supporting the continual process of change within an overall requirement for survival.

At a personal level, you never want to attain a state of having "made it", because by definition then your process will be over, and it is very hard to continually re-activate that "made it" state without some kind of ongoing engaging process. This is presumably why rock stars and movie stars have so many problems with drug abuse --- they get too attached to that amazing state instead of focusing on a sustaining process. Many of the [Grey Space Poems](https://poems.grey-space.org) focus on this issue.

## In the brain

Consistent with a state bias, many theories of brain function focus on _representations_, such as _grid cells_ or _place cells_, instead of the dynamic processes that shape these states. For example, the Nobel prize in medicine was awarded to people who discovered these interesting types of cells, but they inaccurately have concluded that somehow the mere presence of these cells automatically enables animals to navigate through space. Instead, both of these cell types are much better understood in the context of dynamic processes that are engaged in the course of navigation (see [space](https://compcogneuro.org/space) for more details).

## In computer programming

A computer program is a description of a process. Thus, it is a particularly interesting blend of state and process. The essence of such programs is captured by the [Turing machine](https://compcogneuro.org/Turing-machine), which is remarkably simple and yet achieves _universality_: it can compute anything that any other computer can. Interestingly, the _serial_ nature of this process is essential for universality: only serial (sequential) processing can support _arbitrary_ combinations of elemental computations, which is essential for universal capabilities. Thus, it is this property of the _process_ that is so critical.

Another important implication of the overall state bias in the context of programming is the pervasive desire to create _declarative_ state-based representational structures, instead of relying on dynamic processes (programs). Inevitably, these representational systems (e.g., XML / HTML, Makefiles, css, LaTeX, etc) end up adding more and more complexity until they achieve computational universality, thereby effectively reinventing an entirely new programming language. 

Instead, it is much more efficient to just use _functions_ (programs) in one overall language, to accomplish everything that you might otherwise want to do with a declarative structure. This is one of the key [principles](https://www.cogentcore.org/core/principles) of the Cogent Core system that powers this website, for example, and is a central feature of [functional](https://en.wikipedia.org/wiki/Functional_programming) programming languages.


